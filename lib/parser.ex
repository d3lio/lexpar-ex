defmodule Lexpar.Parser do
  @moduledoc """
  LALR(1) parser generator in pure elixir.
  """

  defmacro __using__(opts) do
    entry = Keyword.get(opts, :entry)
    if entry === nil, do: raise "Must specify parser entry."

    quote do
      import Lexpar.Parser

      @doc """
      Parse given input with the grammar generated by multiple `defnonterm`s.

      Possible results are:

      * `{:ok, parse_result, rest_of_input}` - success
      * `{:unexpected, token, position_in_nonterm}` - failure
      * `:eof` - empty input
      """
      def parse(str) when is_binary(str) or is_list(str) do
        __MODULE__.unquote(entry)(str, &iterator/1)
      end

      @doc """
      Iterates over the given input for parsing.

      The default implementation is for lists but can be overriden
      for other structures such as streams.
      """
      def iterator(nil), do: nil
      def iterator([]), do: nil
      def iterator([head | tail]), do: {head, tail}
    end
  end

  @doc """
  Defined a nonterminal for the parser to use.

  The nonterminal is a function that checks if a source input begins with a
  specific sequence of items and acts upon it. These items may come from a
  lexer and be complex structure or can be plain old codepoints. You should not
  try to invoke the nonterms directly but instead use the `parse` function
  generated by using this module.
  """
  defmacro defnonterm(name, do: block) do
    {nonterm, _, _} = name

    quote do
      @doc false
      def unquote(nonterm)(source, iterator) do
        unquote(gen_matchers(parse_block(block), nonterm))
      end
    end
  end

  @doc "Loop throught the nonterm arms."
  def parse_block(block) do
    block |> Enum.map(&parse_rule/1)
  end

  @doc "Parse a nonterm arm."
  def parse_rule(rule) do
    {:->, _, [head, logic]} = rule

    terms = case head do
      [{:when, _, head}] -> head |> parse_head()
      terms -> terms |> parse_terms()
    end

    {terms, logic}
  end

  @doc "Parse the arm header of a nonterm arm."
  def parse_head(head) do
    [guard | terms] = head |> Enum.reverse()
    guards = guard |> parse_guard()
    terms |> Enum.reverse() |> parse_terms(guards)
  end

  @doc """
  Parse the guard of a nonterm arm.

  Right now it only supports nonterm checks delimited with `and`.
  """
  def parse_guard(nil), do: []
  def parse_guard(ast), do: parse_guard(ast, [])
  defp parse_guard({:and, _, [lhs, rhs]}, acc), do: parse_guard(lhs, [rhs | acc])
  defp parse_guard(check, acc), do: [check | acc]

  @doc "Parse each term in a nonterm arm."
  def parse_terms(terms, guards \\ []) do
    terms |> Enum.map(&case &1 do
      {{:., _, [{_, _, nil} = var, :*]}, _, _} -> {:*, pair_with_guard(var, guards)}
      {{:., _, [{_, _, nil} = var, :+]}, _, _} -> {:+, pair_with_guard(var, guards)}
      {:@, _, [{:eps, ctx, nil}]} -> {:_, ctx, :eps}
      {_ , _, nil} = var -> pair_with_guard(var, guards)
      term -> term
    end)
  end

  @doc "Paires a term with it's nonterm guard for code generation"
  def pair_with_guard({ident, _, nil} = var, guards) do
    mapped = guards |> Enum.map(fn {nonterm_check, _, [{guarded, _, nil}]} ->
      nonterm = nonterm_check
      |> Atom.to_string()
      |> String.split_at(3)
      |> Kernel.elem(1)
      |> String.to_atom()

      {guarded, nonterm}
    end)

    Enum.find_value(mapped, var, fn {guarded, nonterm} ->
      if guarded === ident do {:guarded, var, nonterm} else false end
    end)
  end

  @doc "Generate the matchers for the nonterm."
  # {:ok, res, source}
  # {:unexpected, token, position}
  # :eof
  def gen_matchers(content, nonterm) do
    gen_arms(content, nonterm)
  end

  @doc "Generate the nonterm arms."
  def gen_arms(arms, nonterm), do: gen_arms(arms, nonterm, 0)

  defp gen_arms([], nonterm, _) do
    quote do
      {:unexpected, iterator(source) |> Kernel.elem(0), {unquote(nonterm), -1, 0}}
    end
  end

  defp gen_arms([{terms, logic} | arms], nonterm, position) do
    case_nomatch = gen_arms(arms, nonterm, position + 1)

    quote do
      res = unquote(gen_terms(terms, {nonterm, position}, logic))

      case res do
        {:ok, _, _} = success -> success
        # continue trying to match an arm
        :nomatch -> unquote(case_nomatch)
        state -> state
        # {:unexpected, _, _} = unexpected -> unexpected
        # :eof -> :eof
      end
    end
  end

  @doc "Generate a single nonterm arm."
  # {:ok, res, source}
  # :nomatch
  # {:unexpected, token, position}
  # {:unexpected, :eof, -1}
  # :eof
  def gen_terms(terms, meta, logic), do: gen_terms(terms, meta, 0, logic)

  #codegen arm logic
  defp gen_terms([], _, _, logic) do
    quote do
      {:ok, unquote(logic), source}
    end
  end

  # codegen epsilon
  defp gen_terms([{:_, _, :eps}], _, 0, logic) do
    quote do
      {:ok, unquote(logic), source}
    end
  end

  # codegen primitive terms
  defp gen_terms([term | terms], {nonterm, arm} = meta, position, logic)
  when not is_tuple(term) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(term) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(term) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected, :eof, -1}
        end
      end
    end
  end

  # codegen non-guarded idents
  defp gen_terms([{_, _, nil} = var | terms], {nonterm, arm} = meta, position, logic) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected, :eof, -1}
        end
      end
    end
  end

  # codegen kernel-guarded terms
  defp gen_terms([{:guarded, var, nonterm} | terms], {nonterm_name, arm} = meta, position, logic)
  when nonterm in [
    :atom, :binary, :bitstring, :boolean, :float,
    :function, :integer, :list, :map, :nil,
    :number, :pid, :port, :reference, :tuple,
  ] do
    case_matched = gen_terms(terms, meta, position + 1, logic)
    kernel_guard_ident = String.to_atom("is_" |> Kernel.<>(nonterm |> Atom.to_string()))
    kernel_guard = {kernel_guard_ident, [], [var]}

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) when unquote(kernel_guard) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) when unquote(kernel_guard) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm_name), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected, :eof, -1}
        end
      end
    end
  end

  # codegen nonterm-guarded idents
  defp gen_terms(
    [{:guarded, {ident, _, _}, nonterm} | terms],
    {nonterm_name, arm} = meta,
    position,
    logic
  ) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case unquote(nonterm)(source, iterator) do
          {:ok, unquote(Macro.var(ident, nil)), source} -> unquote(case_matched)
          state -> state
        end
      end
    else
      quote do
        case unquote(nonterm)(source, iterator) do
          {:ok, unquote(Macro.var(ident, nil)), source} -> unquote(case_matched)
          {:unexpected, _, _} = unexpected -> unexpected
          :nomatch -> {
            :unexpected,
            iterator(source) |> Kernel.elem(0),
            {unquote(nonterm_name), unquote(arm), unquote(position)}
          }
          :eof -> {:unexpected, :eof, -1}
        end
      end
    end
  end
end
