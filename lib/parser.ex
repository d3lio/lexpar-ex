defmodule Lexpar.Parser do
  @moduledoc """
  LALR(1) parser generator in pure elixir.

  The generated parser does not account yet for left factor nor for left recursion.
  Future support will include dose and Kleene star.

  The public api includes `parse`, `iterator` and `defnonterm`.
  Avoid using the other helpers directly.

  ## Example

  ```
  defmodule Parser do
    use Lexpar.Parser, entry: expr

    defnonterm expr do
      ?(, e, ?) when is_expr(e) -> e
      e when is_number(e) -> e
    end
  end
  Parser.parse([?(, 123, ?)])
  ```
  """

  defmacro __using__(opts) do
    entry = Keyword.get(opts, :entry)
    if entry === nil, do: raise "Must specify parser entry."

    quote do
      import Lexpar.Parser

      @doc """
      Parse given input with the grammar generated by multiple `defnonterm`s.

      For examples look at Lexpar.Parser doc or `defnonterm`.

      This function returns one of the following:

      * `{:ok, parse_result, rest_of_input}` - success
      * `{:unexpected, token, {nonterm_name, arm_number, term_number}}` - failure
      * `{:unexpected_eof, {nonterm_name, arm_number, term_number}}` - failure
      """
      def parse(str) when is_binary(str) or is_list(str) do
        __MODULE__.unquote(entry)(str, &iterator/1)
      end

      @doc """
      Iterates over the given input for parsing.

      The default implementation is for lists but can be overriden
      for other structures such as streams.
      """
      def iterator(nil), do: nil
      def iterator([]), do: nil
      def iterator([head | tail]), do: {head, tail}
    end
  end

  @doc """
  Defined a nonterminal for the parser to use.

  The nonterminal is a function that checks if a source input begins with a
  specific sequence of items and acts upon it. These items may come from a
  lexer and be complex structure or can be plain old codepoints. You should not
  try to invoke the nonterms directly but instead use the `parse` function
  generated by using this module.

  ## Syntax

  ```
  defmodule Parser do
    use Lexpar.Parser, entry: expr

    defnonterm expr do
      ?(, e, ?) when is_expr(e) -> e
      e when is_number(e) -> e
    end
  end
  ```

  ```
  defmodule Parser do
    use Lexpar.Parser, entry: function

    defnonterm function do
      "fn", ?(, args, ?) when is_args(args) -> args
    end

    defnonterm args do
      arg, args when is_atom(arg) and is_args(args) -> [arg | args]
      @eps -> []
    end
  end
  ```

  `@eps` means epsilon. It matches the emtpy input and is useful to implement
  recursive nonterms' bottom or an optional match. It is different from `_`
  as it does not progress the iterator.
  """
  defmacro defnonterm(name, do: block) do
    {nonterm, _, _} = name

    quote do
      @doc false
      def unquote(nonterm)(source, iterator) do
        unquote(gen_matchers(parse_block(block), nonterm))
      end
    end
  end

  @doc "Loop throught the nonterm arms."
  def parse_block(block) do
    block |> Enum.map(&parse_rule/1)
  end

  @doc "Parse a nonterm arm."
  def parse_rule(rule) do
    {:->, _, [head, logic]} = rule

    terms = case head do
      [{:when, _, head}] -> head |> parse_head()
      terms -> terms |> parse_terms()
    end

    {terms, logic}
  end

  @doc "Parse the arm header of a nonterm arm."
  def parse_head(head) do
    [guard | terms] = head |> Enum.reverse()
    guards = guard |> parse_guard()
    terms |> Enum.reverse() |> parse_terms(guards)
  end

  @doc """
  Parse the guard of a nonterm arm.

  Right now it only supports nonterm checks delimited with `and`.
  """
  def parse_guard(nil), do: []
  def parse_guard(ast), do: parse_guard(ast, [])
  defp parse_guard({:and, _, [lhs, rhs]}, acc), do: parse_guard(lhs, [rhs | acc])
  defp parse_guard(check, acc), do: [check | acc]

  @doc "Parse each term in a nonterm arm."
  def parse_terms(terms, guards \\ []) do
    terms |> Enum.map(&case &1 do
      {{:., _, [{_, _, nil} = var, :*]}, _, _} -> {:*, pair_with_guard(var, guards)}
      {{:., _, [{_, _, nil} = var, :+]}, _, _} -> {:+, pair_with_guard(var, guards)}
      {:@, _, [{:eps, ctx, nil}]} -> {:_, ctx, :eps}
      {_ , _, nil} = var -> pair_with_guard(var, guards)
      term -> term
    end)
  end

  @doc "Paires a term with it's nonterm guard for code generation"
  def pair_with_guard({_, _, nil} = var, []), do: var
  def pair_with_guard({ident, _, nil} = var, guards) do
    mapped = guards |> Enum.map(fn {nonterm_check, _, [{guarded, _, nil}]} ->
      nonterm = nonterm_check
      |> Atom.to_string()
      |> String.split_at(3)
      |> Kernel.elem(1)
      |> String.to_atom()

      {guarded, nonterm}
    end)

    Enum.find_value(mapped, var, fn {guarded, nonterm} ->
      if guarded === ident do {:guarded, var, nonterm} else false end
    end)
  end

  @doc "Generate the matchers for the nonterm."
  # {:ok, res, source}
  # {:unexpected, token, position}
  # :eof
  def gen_matchers(content, nonterm) do
    gen_arms(content, nonterm)
  end

  @doc "Generate the nonterm arms."
  def gen_arms(arms, nonterm), do: gen_arms(arms, nonterm, 0)

  defp gen_arms([], nonterm, _) do
    quote do
      {:unexpected, iterator(source) |> Kernel.elem(0), {unquote(nonterm), -1, 0}}
    end
  end

  defp gen_arms([{terms, logic} | arms], nonterm, position) do
    case_nomatch = gen_arms(arms, nonterm, position + 1)

    quote do
      res = unquote(gen_terms(terms, {nonterm, position}, logic))

      case res do
        {:ok, _, _} = success -> success
        # continue trying to match an arm
        :nomatch -> unquote(case_nomatch)
        state -> state
        # {:unexpected, _, _} = unexpected -> unexpected
        # :eof -> :eof
      end
    end
  end

  @doc """
  Generate a single nonterm arm.

  Possible results from calling the generated code:

  * `{:ok, res, source}`
  * `:nomatch`
  * `{:unexpected, token, position}`
  * `{:unexpected_eof, position}`
  * `:eof`
  """
  def gen_terms(terms, meta, logic), do: gen_terms(terms, meta, 0, logic)

  #codegen arm logic
  defp gen_terms([], _, _, logic) do
    quote do
      {:ok, unquote(logic), source}
    end
  end

  # codegen epsilon
  defp gen_terms([{:_, _, :eps}], _, 0, logic) do
    quote do
      {:ok, unquote(logic), source}
    end
  end

  # codegen primitive terms
  defp gen_terms([term | terms], {nonterm, arm} = meta, position, logic)
  when not is_tuple(term) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(term) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(term) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected_eof, {unquote(nonterm), unquote(arm), unquote(position)}}
        end
      end
    end
  end

  # codegen non-guarded idents
  defp gen_terms([{_, _, nil} = var | terms], {nonterm, arm} = meta, position, logic) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected_eof, {unquote(nonterm), unquote(arm), unquote(position)}}
        end
      end
    end
  end

  # codegen kernel-guarded terms
  defp gen_terms([{:guarded, var, nonterm} | terms], {nonterm_name, arm} = meta, position, logic)
  when nonterm in [
    :atom, :binary, :bitstring, :boolean, :float,
    :function, :integer, :list, :map, :nil,
    :number, :pid, :port, :reference, :tuple,
  ] do
    case_matched = gen_terms(terms, meta, position + 1, logic)
    kernel_guard_ident = String.to_atom("is_" |> Kernel.<>(nonterm |> Atom.to_string()))
    kernel_guard = {kernel_guard_ident, [], [var]}

    if position === 0 do
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) when unquote(kernel_guard) -> unquote(case_matched)
              _ -> :nomatch
            end
          nil -> :eof
        end
      end
    else
      quote do
        case iterator(source) do
          {head, source} ->
            case head do
              unquote(var) when unquote(kernel_guard) -> unquote(case_matched)
              _ -> {:unexpected, head, {unquote(nonterm_name), unquote(arm), unquote(position)}}
            end
          nil -> {:unexpected_eof, {unquote(nonterm_name), unquote(arm), unquote(position)}}
        end
      end
    end
  end

  # codegen nonterm-guarded idents
  defp gen_terms(
    [{:guarded, {ident, _, _}, nonterm} | terms],
    {nonterm_name, arm} = meta,
    position,
    logic
  ) do
    case_matched = gen_terms(terms, meta, position + 1, logic)

    if position === 0 do
      quote do
        case unquote(nonterm)(source, iterator) do
          {:ok, unquote(Macro.var(ident, nil)), source} -> unquote(case_matched)
          state -> state
        end
      end
    else
      quote do
        case unquote(nonterm)(source, iterator) do
          {:ok, unquote(Macro.var(ident, nil)), source} -> unquote(case_matched)
          {:unexpected, _, _} = unexpected -> unexpected
          :nomatch -> {
            :unexpected,
            iterator(source) |> Kernel.elem(0),
            {unquote(nonterm_name), unquote(arm), unquote(position)}
          }
          :eof -> {:unexpected_eof, {unquote(nonterm_name), unquote(arm), unquote(position)}}
        end
      end
    end
  end
end
